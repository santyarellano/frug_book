<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pong - FRUG Documentation (for v0.1.0)</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../frug_guide.html"><strong aria-hidden="true">2.</strong> Using FRUG</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guide/creating_a_window.html"><strong aria-hidden="true">2.1.</strong> Setup and creating a window</a></li><li class="chapter-item expanded "><a href="../guide/colored_rectangle.html"><strong aria-hidden="true">2.2.</strong> Drawing a rectangle</a></li><li class="chapter-item expanded "><a href="../guide/background_color.html"><strong aria-hidden="true">2.3.</strong> Background color</a></li><li class="chapter-item expanded "><a href="../guide/texture_rectangle.html"><strong aria-hidden="true">2.4.</strong> Drawing a texture</a></li><li class="chapter-item expanded "><a href="../guide/camera.html"><strong aria-hidden="true">2.5.</strong> Camera and user input</a></li><li class="chapter-item expanded "><a href="../guide/custom_shape.html"><strong aria-hidden="true">2.6.</strong> Creating a custom shape</a></li><li class="chapter-item expanded "><a href="../guide/fullscreen.html"><strong aria-hidden="true">2.7.</strong> Setting fullscreen and window size</a></li></ol></li><li class="chapter-item expanded "><a href="../examples.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/pong.html" class="active"><strong aria-hidden="true">3.1.</strong> Pong</a></li><li class="chapter-item expanded "><a href="../examples/platformer.html"><strong aria-hidden="true">3.2.</strong> Simple platformer</a></li></ol></li><li class="chapter-item expanded "><a href="../contribute_to_frug.html"><strong aria-hidden="true">4.</strong> Contributing to the project</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">FRUG Documentation (for v0.1.0)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/santyarellano/frug" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pong"><a class="header" href="#pong">Pong</a></h1>
<p>Pong is sometimes considered as the &quot;Hello World&quot; of games. A simple game which can let's us explore how things work. With FRUG this won't be the exception and we'll develop a simple version of Pong to explore how to use FRUG beyond simple feature examples. </p>
<p>The first thing we'll need is our <code>main.rs</code> with our frug instance initialization, our empty update function, and the <code>run</code> call. You should have something like this:</p>
<pre><pre class="playground"><code class="language-rust">use frug;
use cgmath::Vector2;

fn main() {
    let (frug_instance, event_loop) = frug::new(&quot;Pong!&quot;);

    let update_function = move |instance: &amp;mut frug::FrugInstance, input: &amp;frug::InputHelper| {
        // Rendering
        instance.clear();
        instance.update_buffers();
    };

    frug_instance.run(event_loop, update_function);
}</code></pre></pre>
<p>Oh, and don't forget to add FRUG to your <code>Cargo.toml</code>! (we'll also need another crate called <code>cgmath</code> so you might add it as well).</p>
<pre><code class="language-toml"># ...

[dependencies]
cgmath = &quot;0.18&quot;
frug = &quot;*&quot;
</code></pre>
<p>Now, let's quickly go over what things we'll need, shall we?</p>
<ul>
<li>Our &quot;player&quot; (just a rectangle to represent the player's paddle/racket).</li>
<li>The oponent (almost the same as the player).</li>
<li>The ball</li>
</ul>
<p>We could technically need more things, but for the sake of simplicity we'll only use those three things. Now, again for simplicity we'll just use rectangles for all 3 objects, yet the ball will obviously be smaller (a small square). This &quot;ball&quot; will start at the center of the screen and move to a random side of the screen to start the game. The &quot;opponent&quot; will just move to try to align the vertical center of the paddle with the center of the ball. And finally, we'll just let the player control their paddle through the keyboard's arrows.</p>
<p>Let's start by creating the ball and the opponent, as it allows us to start developing the simple aspects of our game right away.</p>
<p>We can start by creating a struct called &quot;CollisionRectangle&quot; which will help us to manage our 3 objects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CollisionRectangle {
    pos: Vector2&lt;f32&gt;,
    width: f32,
    height: f32,
    vel: Vector2&lt;f32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>You might notice that we're using <code>Vector2&lt;i32&gt;</code> for our position and velocity. This might look familiar if you've used Unity or other engines, but in case you don't know them just keep in mind that they will simply hold 2 components (x and y) for us to represent those attributes.</p>
</blockquote>
<p>And we could also use a method to initialize new instances of our struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CollisionRectangle {
    fn new(x: f32, y: f32, width: f32, height: f32) -&gt; CollisionRectangle {
        CollisionRectangle {
            pos: Vector2 { x, y },
            width,
            height,
            vel: Vector2 { x: 0.0, y: 0.0 },
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now that we have our struct, we can define our ball! (do this inside your main function but before your update function)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

// our objects
let mut ball: CollisionRectangle = CollisionRectangle::new(-0.05, -0.05, 0.1, 0.1);
<span class="boring">}</span></code></pre></pre>
<p>Now all we need to do is render our ball! For this we will simply draw a rectangle using our FRUG instance, just like we did in the tutorial (this goes in our update function after the <code>clear()</code> function call).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>instance.add_colored_rect(
    ball.pos.x,
    ball.pos.y,
    ball.width,
    ball.height,
    [1.0, 1.0, 1.0],
);
<span class="boring">}</span></code></pre></pre>
<p>If you run this now you'll notice that it will just show our screen and a weird rectangle. This happens because the coordinates of the &quot;world&quot; are from -1 to 1 on every direction, so if your window is not a square it is logical that the ball won't look like a square. We can easy-fix this by just making our window have the same height as it's width.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This goes before our update function.
frug_instance.set_window_size(800.0, 800.0);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>You might be thinking that this will be a severe issue when we want to work with a window that is not square-sized. Yes, you're right. This is always an issue and every engine and framework allows multiple types to solve this. In such cases it's better just to understand how the framework/engine/library works and use the solution that works best for you.</p>
</blockquote>
<p>Now that we have a &quot;ball&quot; in our game, we need some way to make it start moving. For this we will just check if the player pressed the return key and if the ball isn't moving. If that's the case we will set the speed of the ball and a random direction (left or right).</p>
<p>We'll do this inside our update function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let paddle_speed = 0.006;

// start moving the ball if it's not moving
if input.key_pressed(frug::VirtualKeyCode::Return) {
    if ball.vel.x == 0.0 {
        let dir = if rng.gen_bool(0.5) { -1.0 } else { 1.0 };
        ball.vel.x = 0.01 * dir;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And now we need to actually move the ball each frame. As this is something that we'll need to do for every object in our game lets add it in the implementation of our <code>Collision Rectangle</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_pos(&amp;mut self) {
    self.pos += self.vel;
}
<span class="boring">}</span></code></pre></pre>
<p>And we'll call that method inside our update function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// updates
ball.update_pos();
<span class="boring">}</span></code></pre></pre>
<p>If you run this and hit the return key you'll notice that the ball starts moving!</p>
<p>Now we'll need something our ball can actually bounce with, so why don't we start working with the player's paddle?</p>
<p>For this, just as we did with the ball, we'll need to create another instance of our <code>CollisionRectangle</code>. You can add this next to the init of our ball.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut player = CollisionRectangle::new(-0.9, 0.2, 0.1, 0.5);
<span class="boring">}</span></code></pre></pre>
<p>And draw a rectangle each frame in the same way we did with our ball.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>instance.add_colored_rect(
    player.pos.x,
    player.pos.y,
    player.width,
    player.height,
    [1.0, 1.0, 1.0],
);
<span class="boring">}</span></code></pre></pre>
<p>And we can add a call to it's <code>update_pos</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// updates
ball.update_pos();
player.update_pos(); // &lt;- NEW!
<span class="boring">}</span></code></pre></pre>
<p>Now, the movement for our &quot;player&quot; will be based on input, so let's just add a variable called <code>paddle_speed</code>, which we will use both with our player and the opponent. We'll keep things simple and add that to the player's vertical velocity if they upwards key is being pressed, and substract it with the downwards key (oh, and set the player's Y velocity to 0 each frame). This way if the player is pressing both keys at the same time the paddle will stop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let paddle_speed = 0.006;

// move player
player.vel.y = 0.0;
if input.key_held(frug::VirtualKeyCode::Up) {
    player.vel.y += paddle_speed;
}
if input.key_held(frug::VirtualKeyCode::Down) {
    player.vel.y -= paddle_speed;
}
<span class="boring">}</span></code></pre></pre>
<p>If you try this out you should see that the paddle can move when you press the keys! However, you'll also notice that the ball can absolutely ignore our paddle and go through it and into the infinity. Let's fix that. </p>
<p>We can start with the simple things and reset the ball if it goes outside the screen. For this we will need a function to check if the ball has gone outside the screen. This is not a good practice but for the sake of simplicity let's just add it in our <code>CollisionRectangle</code> implementation (or feel free to do it in a better way!).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_game_over(&amp;mut self) -&gt; bool {
    if self.pos.x - self.width * 2.0 &gt;= 1.0 || self.pos.x + self.width * 2.0 &lt; -1.0 {
        return true;
    }
    return false;
}
<span class="boring">}</span></code></pre></pre>
<p>And we'll check for this at some point in our update function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// check if it's game over
if ball.is_game_over() {
    // restart ball
    ball.pos.x = -0.05;
    ball.pos.y = -0.05;
    ball.vel.x = 0.0;
    ball.vel.y = 0.0;
}
<span class="boring">}</span></code></pre></pre>
<p>With that done we need to make the ball bounce with our paddle and with the vertical limits of the screen. This time we'll go through the more elaborate part of it, colliding with the paddle. I won't go into much detail with this function, just know that we'll do it in the implementation of the <code>CollisionRectangle</code> and we'll do it in some way to receive another object as parameter and bounce against it in the x axis and set a new vertical direction randomly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function will only work for the ball!
fn check_collision(&amp;mut self, obj: &amp;CollisionRectangle) {
    let mut rng = rand::thread_rng();

    let tolerance_w = 0.15 * self.width; // percentage of shape
    let tolerance_h = 0.15 * self.height; // percentage of shape

    // Horizontal collision
    if self.pos.y - tolerance_h &gt; obj.pos.y - obj.height {
        if self.pos.y - tolerance_h &lt; obj.pos.y {
            // give priority for horizontal collision
            if self.pos.x &lt; obj.pos.x + obj.width {
                if self.pos.x &gt; obj.pos.x {
                    // Left collision is happening
                    self.vel.x *= -1.0;
                    self.vel.y = rng.gen_range(-0.01..0.01);
                    return;
                }
            }

            if self.pos.x + self.width &gt; obj.pos.x {
                if self.pos.x + self.width &lt; obj.pos.x + obj.width {
                    // Right collision is happening
                    self.vel.x *= -1.0;
                    self.vel.y = rng.gen_range(-0.01..0.01);
                    return;
                }
            }
        }
    }

    // Vertical collision
    if self.pos.x + tolerance_w &lt; obj.pos.x - obj.width {
        if self.pos.x + tolerance_w &gt; obj.pos.x {
            // give priority for vertical collision
            if self.pos.y &gt; obj.pos.y - obj.height {
                if self.pos.y &lt; obj.pos.y {
                    // Up collision is happening
                    self.vel.y *= -1.0;
                    return;
                }
            }

            if self.pos.y - self.height &lt; obj.pos.y {
                if self.pos.y - self.height &gt; obj.pos.y - obj.height {
                    // Down collision is happening
                    self.vel.y *= -1.0;
                    return;
                }
            }
        }
    }

    // No collision was detected
}
<span class="boring">}</span></code></pre></pre>
<p>And for the ball to bounce with the floor and ceiling we'll do something similar to what we did to reset the ball.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_collision_screen(&amp;mut self) {
    if self.pos.y &gt;= 1.0 {
        if self.vel.y &gt; 0.0 {
            self.vel.y *= -1.0;
        }
    } else if self.pos.y - self.height &lt; -1.0 {
        if self.vel.y &lt; 0.0 {
            self.vel.y *= -1.0;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now we need to add those calls inside our update function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// bounce ball in case of collision
ball.check_collision(&amp;player);
ball.check_collision_screen();
<span class="boring">}</span></code></pre></pre>
<p>And with that done we should have a ball that neatly bounces with our player's paddle!</p>
<blockquote>
<p>You might notice that there's a very rare situation where the ball gets trapped between the floor/ceiling and the paddle. For the sake of simplicity of this example I'm not fixing that issue but feel free to try your own solution!</p>
</blockquote>
<p>Now all we have left to do is to create our opponent. Fortunately, it is really easy now that we've done the hard parts. We can start by adding a new instance of the <code>CollisionRectangle</code> for our opponent.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut opponent = CollisionRectangle::new(0.8, 0.2, 0.1, 0.5);
<span class="boring">}</span></code></pre></pre>
<p>Add it's checks for collisions with our ball.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ball.check_collision(&amp;opponent);
<span class="boring">}</span></code></pre></pre>
<p>Then the call to <code>update_pos</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>opponent.update_pos();
<span class="boring">}</span></code></pre></pre>
<p>And our drawing of the opponent's rectangle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>instance.add_colored_rect(
    opponent.pos.x,
    opponent.pos.y,
    opponent.width,
    opponent.height,
    [1.0, 1.0, 1.0],
);
<span class="boring">}</span></code></pre></pre>
<p>Finally, we need some sort of AI to move our paddle. In this case we'll keep things simple and just try to align the center of the opponent with the center of the ball.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// move opponent
let opponent_y = opponent.pos.y - (opponent.height / 2.0);
let ball_y = ball.pos.y - (ball.height / 2.0);
if opponent_y &gt; ball_y {
    opponent.vel.y = -paddle_speed;
} else if opponent_y &lt; ball_y {
    opponent.vel.y = paddle_speed;
}
<span class="boring">}</span></code></pre></pre>
<p>And... done! If you've gone through these steps you should be able to play pong!</p>
<p><img src="../img/pong.png" alt="Our pong game." /></p>
<p>Now that we've gone through a simple game, why don't we try something that involves sprites and a bit more color?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../examples.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../examples/platformer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../examples.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../examples/platformer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
